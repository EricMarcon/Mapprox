---
title: "Title of the Article"
author:
  - name: "First Author's name"
  - name: "Second Author's name"
abstract: >
  Abstract of the article.
date: "`r format(Sys.time(), '%d %B %Y')`"
url: https://EricMarcon.github.io/Mapprox/
github-repo: EricMarcon/Mapprox
# Language
lang: fr-FR
# Bibliography
bibliography: references.bib
biblio-style: chicago
# LaTeX
preamble: >
  \hyphenation{bio-di-ver-si-ty sap-lings}
# Print table of contents in PDFs?
pdftoc: false
# If true, choose its depth
toc-depth: 3
# URL color
urlcolor: blue
# Do not modify
always_allow_html: yes
csquotes: true
output:
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    css: style.css
    code_folding: show
  rmdformats::downcute:
    use_bookdown: yes
    lightbox: yes
  bookdown::gitbook:
    config:
      download: "pdf"
      sharing:
        github: yes
  bookdown::pdf_book:
    template: latex/template.tex
    citation_package: natbib
    latex_engine: xelatex
    keep_tex: yes
  bookdown::word_document2: default
---

```{r DoNotModify, include=FALSE}
### Utilities. Do not modify.
# Installation of packages if necessary
InstallPackages <- function(Packages) {
  InstallPackage <- function(Package) {
    if (!Package %in% installed.packages()[, 1]) {
      install.packages(Package, repos="https://cran.rstudio.com/")
    }
  }
  invisible(sapply(Packages, InstallPackage))
}

# Basic packages
InstallPackages(c("bookdown", "formatR", "kableExtra", "ragg"))

# kableExtra must be loaded 
if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "docx") {
  # Word output (https://stackoverflow.com/questions/35144130/in-knitr-how-can-i-test-for-if-the-output-will-be-pdf-or-word)
  # Do not use autoformat (https://github.com/haozhu233/kableExtra/issues/308)
  options(kableExtra.auto_format = FALSE)
}
library("kableExtra")

# Chunk font size hook: allows size='small' or any valid Latex font size in chunk options
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})
```

```{r Options, include=FALSE}
### Customized options for this document
# Add necessary packages here
Packages <- c("tidyverse", "spatstat", "dbmss")
# Install them
InstallPackages(Packages)

# knitr options
knitr::opts_chunk$set(
  cache =   FALSE,    # Cache chunk results
  include = TRUE,     # Show/Hide chunks
  echo =    TRUE,     # Show/Hide code
  warning = FALSE,    # Show/Hide warnings
  message = FALSE,    # Show/Hide messages
  # Figure alignment and size
  fig.align = 'center', out.width = '80%',
  # Graphic devices (ragg_png is better than standard png)
  dev = c("ragg_png", "pdf"),
  # Code chunk format
  tidy = TRUE, tidy.opts = list(blank=FALSE, width.cutoff=50),
  size = "scriptsize", knitr.graphics.auto_pdf = TRUE
  )
options(width = 50)

# ggplot style
library("tidyverse")
theme_set(theme_bw())
theme_update(panel.background=element_rect(fill="transparent", colour=NA),
             plot.background=element_rect(fill="transparent", colour=NA))
knitr::opts_chunk$set(dev.args=list(bg="transparent"))

# Random seed
set.seed(973)
```

# Motivation

# Tirage des points

```{r}
#| label: Parametres
points_nb <- 100000
case_ratio <- 1/20
size_gamma_shape <- 1
size_gamma_scale  <- 10
```


```{r}
library("tidyverse")
library("spatstat")
library("dbmss")
X_draw <- function() {
  points_nb %>% 
    runifpoint() %>% 
    as.wmppp() ->
    X
  cases_nb <- round(points_nb *  case_ratio)
  controls_nb <- points_nb - cases_nb
  c(rep("Control", controls_nb), rep("Case", cases_nb)) %>% 
    as.factor() ->
    X$marks$PointType
  X$marks$PointWeight <- rgamma(100, shape = size_gamma_shape, scale = size_gamma_scale)
  X
}
X <- X_draw()
```

# Grille

```{r}
partitions <- 100
r <- c((0:9) / 100, (2:10) / 20)
```

```{r}
# Group points into cells
group_points <- function(X, partitions) {
X %>%
  with(tibble(
    x, 
    y, 
    PointType = marks$PointType, 
    PointWeight = marks$PointWeight)
  ) %>% 
  mutate(
    x_cell = ceiling(x * partitions) / partitions - 1 / 2 / partitions,
    y_cell = ceiling(y * partitions) / partitions - 1 / 2 / partitions
  ) %>%
  group_by(PointType, x_cell, y_cell) %>% 
  summarise(n = n(), PointWeight = sum(PointWeight)) %>% 
  rename(x = x_cell, y = y_cell) %>% 
  as.wmppp(window = X$window, unitname = X$window$units)
}
```

```{r}
group_points(X, partitions) %>% autoplot(alpha = 0.5)
```

```{r}
simulations_n <- 100

# Compute M
X_to_M <- function(X) {
  X %>% 
  Mhat(r = r, ReferenceType = "Case", NeighborType  = "Control") %>% 
  pull("M")
}
```



# Test

```{r}
# Simulate X
X_list <- replicate(simulations_n, X_draw(), simplify = FALSE)
# Compute M
system.time(M_original <- sapply(X_list, X_to_M))

# Group points and compute M
X_grouped_list <- lapply(X_list, group_points, partitions = partitions)
# Compute M
system.time(M_grouped <- sapply(X_grouped_list, X_to_M))

 # Correlation
M_cor <- function(r_value) {
  r_index <- which(r == r_value)
  c(
    r_value,
    cor(M_original[r_index, ], M_grouped[r_index, ])
  ) 
}
sapply(r, M_cor) %>% t() %>% as_tibble() %>% rename(r = V1, correlation = V2)
```

